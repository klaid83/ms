./vendor/bin/doctrine-module orm:info
./vendor/bin/doctrine-module orm:validate-schema
./vendor/bin/doctrine-module orm:schema-tool:create
./vendor/bin/doctrine-module orm:schema-tool:update --force

===============================================================================================
                    Mapping One to One

------------     -----------------------------
   user                   comment
------------     -----------------------------
id | name          id |   message   | user_id
------------     -----------------------------
 1 | name1          1 |   message1  |   2
------------     -----------------------------
 2 | name2          2 |   message2  |   1
------------     -----------------------------

===============================================================================================
                    Mapping One to Many

------------     -----------------------------
   user                   comment
------------     -----------------------------
id | name          id |   message   | user_id
------------     -----------------------------
 1 | name1          1 |   message1  |   2
------------     -----------------------------
 2 | name2          2 |   message2  |   1
------------     -----------------------------
                    3 |   message2  |   2
                 -----------------------------
                    4 |   message2  |   2
                 -----------------------------
                    5 |   message2  |   1
                 -----------------------------

===============================================================================================
                Mapping One to Many Self Ref

----------------------------------
           comment
----------------------------------
  id |   parent_id  |  message
----------------------------------
   1 |     null     |  parent
----------------------------------
   2 |       1      |  children1
----------------------------------
   2 |       1      |  children2
----------------------------------

===============================================================================================
                        Mapping Many to Many

------------     --------------------     ---------------------------
   user               category                 user_category
------------     --------------------     ---------------------------
id | name          id |   name              user_id   |  category_id
------------     --------------------     ---------------------------
 1 | user1          1 |   category1            1      |      1
------------     --------------------     ---------------------------
 2 | user2          2 |   category2            1      |      2
------------     --------------------     ---------------------------
                                               2      |      2
                                          ---------------------------

===============================================================================================












CREATE TABLE menu
(
  `id` INT(11) NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(255) NOT NULL,
  `label` VARCHAR(255) NOT NULL,
  `route` VARCHAR(255) NOT NULL,
  CONSTRAINT pk_menu PRIMARY KEY (id )
)ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;


MxcLayoutScheme

Введение

Вы когда-нибудь хотели, чтобы применить другой макет PHTML на основе согласованной маршруту или для конкретного модуля, контроллера или действия?
Это то, что MxcLayoutScheme может сделать для вас.
MxcLayoutScheme позволяет динамически обмениваться шаблон макета, используемый визуализации.
Вы определяете макета схемы, которые свод правил для выбора раскладки.
В каждой схеме можно назначить отдельную раскладку на конкретном маршруте совпало.
Далее вы можете определить четкую разметку для каждого модуля, контроллера и действия.
MxcLayoutScheme поддерживает конфигурации ребенок ViewModels вместе с ассоциированными шаблонов представления, чтобы оказана захватывает вы определяете.
Кроме того, MxcLayoutScheme перехватывает направить ошибки.
Вы можете обратиться макеты для конкретных кодов ошибок и кодов состояния HTTP так же вы делаете для маршрутов и контроллеров.
MxcLayoutScheme предоставляет интерфейс событий, чтобы позволить вам выбрать схему макета применяется во время загрузки.


Особенности / Цели

Основной целью разработки является MxcLayoutScheme для инкапсуляции компоновки конкретные параметры в прикладных макета Шаблон,
насколько это возможно. Мы хотим добиться того, чтобы в течение действия контроллера как можно меньше еще предстоит сделать в
отношении макета. Так контроллер программисты могут сосредоточиться на страницу "Содержание" части страницы,
независимо от целевой макета (который может быть очень различна для разных целевых платформ (JQuery, JQuery Mobile, Dojo, ... что угодно).

1. Обеспечить возможность назначить расположение динамически
    на основе текущего маршрута согласованного
    для каждого модуля
    для каждого контроллера
    для каждого действия осуществлен контроллером

2. Обеспечить иерархическую согласование модулей, контроллеров, действий и маршрутов
    маршрут матч заменяет матч действий
    Матч действий заменяет контроллер матч
    Контроллер матч заменяет модуль матч
    Модуль матч заменяет глобальные настройки

3. инкапсуляции правила отбора макет в компоновочных схем
4. Поддержка, чтобы добавить дочерние ViewModels в макет конфигурацией
5. Разрешить выбор активной схемы компоновки на основе пользовательских критериев
    Вы можете выбрать выбор при макет в ответ на событие, предоставленной.
6. Разрешить конфигурацию глобального макета по умолчанию для каждой схемы расположения
7. Обеспечить крючки для пред- и постобработки
8. Обеспечить плагин ДУ для управления выбор схемы и настройки переменных макета
9. Обеспечить поддержку ошибки диспетчерских
10. Обеспечить поддержку шаблона Просмотр содержимого
    В текущей версии вы можете назначить переменные макета в контроллере действия, используя layoutScheme плагина контроллера.
    В качестве альтернативы вы можете указать обработчик событий для пред- и постобработки. Мы предоставляем пример здесь.

Опции

Модуль MxcLayoutScheme имеет опции для настройки и выберите компоновочных схем. После установки MxcLayoutScheme, скопируйте
./vendor/maxence/MxcLayoutScheme/config/mxclayoutscheme.global.php.dist to ./config/autoload/mxclayoutscheme.global.php
и изменить значения, как требуется.

Варианты состоять из двух разделов:

defaults  - Настройки для управления работой службы
options   - Настройки для различных компоновочных схем

    'mxclayoutscheme' => array(
        'defaults' => array(
            'active_scheme' => 'myScheme',   //-- name of your layout scheme definition
            'enable_mca_layouts' => true,    //-- apply layouts based on
                                             //-- module, controller, action
            'enable_route_layouts' => true   //-- apply layouts based on routes`
            'enable_error_layouts' => true;  //-- apply layouts for dispatch errors
            'enable_status_layouts' => true; //-- apply layouts based on response status codes
        ),
        'options' => array(
            <scheme-definition>,
            ...
        ),
    );

active_scheme         - Имя схемы, которая активна по умолчанию. По умолчанию ZF2 стандарта.
enable_mca_layouts    - Правила модуль, контроллер, действие получить применяется для выбора макета. По умолчанию: правда
enable_route_layouts  - Правила модуль, контроллер, действие получить применяется для выбора макета. По умолчанию: правда
enable_status_layouts - Правила, основанные на код статуса получить применяется для выбора макета на ошибках отправки. По умолчанию: правда
enable_error_layouts  - Правила, основанные на код ошибки событий получить применяется для выбора макета на ошибках отправки. По умолчанию: правда

каждый <scheme-definition> состоит из четырех разделов:

'myScheme' => array(
        'mca_layouts' => array(
            'options' => array(
                <mca-rule-definition>,
                ...
            ),
            'defaults => array(
                <default-settings>
            ),
        ),
        'route_layouts' => array(
            'options' => array(
                <route-rule-definition>,
                ...
            ),
            'defaults => array(
                <default-settings>
            ),
        ),
        'error_layouts' => array(
            'options' => array(
                <error-rule-definition>,
                ...
            ),
            'defaults => array(
                <default-settings>
            ),
        ),
        'status_layouts' => array(
            'options' => array(
                <status-rule-definition>,
                ...
            ),
            'defaults => array(
                <default-settings>
            ),
        ),
    );

каждый из этих разделов является обязательным (независимо от настроек enable_xxxLayouts).


Ключи Правило Определение

Все <xxx-rule-definition> имеют одинаковую структуру.
Ключ массива указывает правило, значения указать шаблоны компоновки, чтобы применить.

<mca_layouts>

Ключи для <mca_layouts>, как <moduleName>[\<controllerName>[\<actionName>]], где <moduleName> это имя модуля, <controllerName> это имя контроллера, поскольку он зарегистрирован в ControllerLoader <actionName> является именем действия контроллера.

    Examples
        Generic
            'MyModule'                          //--- распространяется на все контроллеры в модуле
            'MyModule\MyController'             //--- относится ко всем действиям контроллера
            'MyModule\MyController\MyAction'    //--- относится к определенному действию контроллера
        ZfcUser controller (registered as zfcuser)
            'ZfcUser'                           //--- распространяется на все контроллеры ZfcUser (здесь только один;)
            'ZfcUser\zfcuser'                   //--- применимо к контроллеру, зарегистрированного 'zfcuser'
                                                //--- (ZfcUser\Controller\UserController)
            'ZfcUser\zfcuser\login'             //--- login action
        MxcUserManagement controller (registered as 'MxcUserManagement\Controller\UserManagement')
            'MxcUserManagement'                 //--- распространяется на все контроллеры модуля MxcUserManagement
            'MxcUserManagement\MxcUserManagement\Controller\UserManagement'
                                                //--- применяется к контроллеру с зарегистрирована 'MxcUserManagement\Controller\UserManagement'
                                                //--- *** В этом правиле первое вхождение 'MxcUserManagement' идентифицирует модуль.
                                                //--- *** Второй появление является частью регистрационного контроллер строки.
            'MxcUserManagement\MxcUserManagement\Controller\UserManagement\index'   //--- index action


Правила действий оцениваются, прежде чем правила контроллера. Правила контроллера оценены перед правилами модуля.
Так, если применить правило действий и правила модуля для того же модуля, правило применяется модуль для всех контроллеров и действий, но в одном действии, которое имеет собственное правило.


<route_layouts>
    Ключи для <route_layouts>, как <route>, где <route> является зарегистрированным маршрут.

<status_layouts>
    Ключи для <status_layouts>, как <status>, где <status> это код статуса (type string).

    Example
        '403'           //--- applies to status code 403


<error_layouts>
    Ключи для <error_layouts>, как <error>, где <error> это код ошибки, возвращаемый MvcEvent (type string).



Значения Правило Определение

Каждое определение правило список таких ценностей, как <capture> => <template>.
Особое захвата "layout" определяет расположение применяется к корневой ViewModel.
Все другие захваты определить ребенка ViewModels которые получают, применяемые к корневой ViewModel с захватом <capture>,
используя шаблон <template>.
Шаблон имена должны быть разрешимы либо TemplatePathStack или TemplateMap резольверами.

    Example mca rule:
        'MyModule\MyController\index' => array(
            'layout'    => 'layout/layout',
            'panelLeft' => 'layout/panel-left',
            'header'    => 'layout/header',
            'footer'    => 'layout/footer',
        ),



Правило Строительство

    При построении макета установки, чтобы применить услугу инициализирует набор со значениями из раздела "defaults".
    Тогда, если правило совпадает, конкретный набор, связанный с правилом перекрывает / продолжается набор по умолчанию.

    Example
        route_layouts => array(
            'options' => array(
                'home' => array(
                    'panelLeft' => 'layout/panel-left'
                ),
            ),
            'defaults' => array(
                'layout' => 'layout/layout',
                'header' => 'layout/header',
                'footer' => 'layout/footer',
            ),
        ),


Доступ к маршруту home  вызывает матч по правилу.
По умолчанию применяется и получить впоследствии настройки из согласованного правила. Таким образом, в результате набор шаблон:


    Example result

        array(
            'panelLeft' => 'layout/panel-left'
            'layout' => 'layout/layout',
            'header' => 'layout/header',
            'footer' => 'layout/footer',
        ),


Как работает MxcLayoutScheme

1. На Bootstrap MxcLayoutScheme крючки в случае маршрутной EventManager приложения с низким приоритетом (-2000).
2. На начальной загрузки MxcLayoutScheme экземпляр контроллера плагин 'layoutScheme ", чтобы ввести ссылку на экземпляр ServiceManager приложения.
3. На маршруте MxcLayoutScheme оценивает текущий маршрут совпадают, имя модуля, имя контроллера и имя действия.
4. Тогда MxcLayoutScheme инициирует событие MxcLayoutSchemeService::HOOK_PRE_SELECT_SCHEME. Если вы зарегистрированы обработчик событий для этого события, в момент загрузки где-то вы можете установить активную схему с $e->getTarget()->setActiveScheme($schemeName) с $schemeName вашему выбору. Кроме того, вы можете установить активную схему в пределах действия контроллера с помощью плагина контроллера: $this->layoutScheme()->setActiveScheme($schemeName).
5. Затем, MxcLayoutScheme загружает текущую активную схему управления
6. MxcLayoutScheme проверяет route_layouts для ключом, соответствующим согласованной название маршрута. Если ключ существует шаблон макета зарегистрировано этом матче будет применяться. Если правило определяет дочерние модели зрения они сливаются с моделями (опционально) определяется детей умолчанию Посмотреть и получить применяется к раскладке. Если матч по-прежнему на 11
7. Затем MxcLayoutScheme проверяет mca_layouts для ключевого Module\Conroller\Action. Если ключ существует шаблон макета зарегистрировано этом матче будет применяться. Если правило определяет дочерние модели зрения они сливаются с моделями (опционально) определяется детей умолчанию Посмотреть и получить применяется к раскладке. Если матч по-прежнему на 11
8. Затем, MxcLayoutScheme проверяет mca_layouts для ключевого соответствия Module\Conroller. Если ключ существует шаблон макета зарегистрировано этом матче будет применяться. Если правило определяет дочерние модели зрения они сливаются с моделями (опционально) определяется детей умолчанию Посмотреть и получить применяется к раскладке. Если матч по-прежнему на 11
9. Затем MxcLayoutScheme проверяет mca_layouts для ключом, соответствующим модуль. Если ключ существует шаблон макета зарегистрировано этом матче будет применяться. Если правило определяет дочерние модели зрения они сливаются с моделями (опционально) определяется детей умолчанию Посмотреть и получить применяется к раскладке. Если матч по-прежнему на 11.
10. Затем, MxcLayoutScheme проверяет по умолчанию для ключевых глобальных. Если ключ существует шаблон макета зарегистрировано этом матче будет применяться. Если правило определяет дочерние модели зрения они сливаются с моделями (опционально) определяется детей умолчанию Посмотреть и получить применяется к раскладке.
11. Наконец MxcLayoutScheme инициирует событие MxcLayoutSchemeService :: HOOK_POST_LAYOUT_SELECT. Вы можете зарегистрировать обработчик событий, чтобы сделать пользовательский пост-обработки. Пример: Связать переменные выбранного макета ViewModel, и это ребенок ViewModels помощью плагина контроллера. Смотрите пример ниже


При применении ребенка макеты MxcLayoutScheme поддерживает ссылки для ребенка ViewModels для использования плагина контроллер '' layoutScheme. Плагин контроллер позволяет применять переменные в моделях зрения ребенка изнутри действия контроллера.















































